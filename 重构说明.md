# MVVM 架构重构说明

## 重构概述

本次重构按照 Google 最新的官方标准，对项目进行了全面升级，主要改进包括：

1. ✅ 使用 StateFlow 替代 LiveData
2. ✅ 引入 Hilt 依赖注入
3. ✅ 使用 Repository 接口实现依赖倒置
4. ✅ 改进错误处理和状态管理
5. ✅ 使用密封类表示 UI 状态
6. ✅ 优化生命周期感知

## 主要改进点

### 1. StateFlow 替代 LiveData

**为什么使用 StateFlow？**

```kotlin
// 旧版本 - LiveData
private val _users = MutableLiveData<List<User>>()
val users: LiveData<List<User>> = _users

// 新版本 - StateFlow
private val _uiState = MutableStateFlow<UserUiState>(UserUiState.Loading)
val uiState: StateFlow<UserUiState> = _uiState.asStateFlow()
```

**StateFlow 的优势：**
- 更现代的 Kotlin 协程 API
- 支持强大的操作符（map, filter, combine, flatMapLatest 等）
- 更好的类型安全
- 与 Kotlin Flow 生态系统无缝集成
- 支持冷流和热流的转换
- 更灵活的背压处理

**在 Fragment 中收集 StateFlow：**

```kotlin
// 使用 repeatOnLifecycle 确保生命周期安全
viewLifecycleOwner.lifecycleScope.launch {
    viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
        viewModel.uiState.collect { state ->
            handleUiState(state)
        }
    }
}
```

### 2. Hilt 依赖注入

**为什么使用 Hilt？**

Hilt 是 Google 推荐的 Android 依赖注入框架，基于 Dagger 构建。

**核心组件：**

1. **Application 类**
```kotlin
@HiltAndroidApp
class MvvmApplication : Application()
```

2. **Activity/Fragment**
```kotlin
@AndroidEntryPoint
class MainActivity : AppCompatActivity()

@AndroidEntryPoint
class UserFragment : Fragment()
```

3. **ViewModel**
```kotlin
@HiltViewModel
class UserViewModel @Inject constructor(
    private val userRepository: UserRepository
) : ViewModel()
```

4. **Module**
```kotlin
@Module
@InstallIn(SingletonComponent::class)
abstract class AppModule {
    @Binds
    @Singleton
    abstract fun bindUserRepository(
        userRepositoryImpl: UserRepositoryImpl
    ): UserRepository
}
```

**Hilt 的优势：**
- 减少样板代码
- 编译时验证依赖图
- 自动管理生命周期
- 与 Android 组件深度集成
- 便于单元测试（可以轻松替换依赖）

### 3. Repository 接口

**依赖倒置原则：**

```kotlin
// 接口定义
interface UserRepository {
    fun getUsers(): Flow<Result<List<User>>>
    suspend fun getUserById(id: Int): Result<User?>
    suspend fun refreshUsers(): Result<List<User>>
}

// 实现类
@Singleton
class UserRepositoryImpl @Inject constructor() : UserRepository {
    // 实现细节
}
```

**好处：**
- ViewModel 依赖接口而非具体实现
- 便于单元测试（可以创建 Mock 实现）
- 便于切换不同的数据源实现
- 符合 SOLID 原则

### 4. 密封类表示 UI 状态

**使用密封类的好处：**

```kotlin
sealed class UserUiState {
    object Loading : UserUiState()
    object Empty : UserUiState()
    data class Success(val users: List<User>) : UserUiState()
    data class Error(val message: String) : UserUiState()
}
```

**优势：**
- 类型安全，编译时检查所有分支
- 清晰表达所有可能的状态
- when 表达式强制处理所有情况
- 避免多个布尔标志的混乱

**在 View 中处理：**

```kotlin
when (state) {
    is UserUiState.Loading -> showLoading()
    is UserUiState.Success -> showSuccess(state.users)
    is UserUiState.Error -> showError(state.message)
    is UserUiState.Empty -> showEmpty()
}
```

### 5. Flow 操作符

**使用 Flow 操作符简化代码：**

```kotlin
userRepository.getUsers()
    .onStart {
        // 开始时显示加载状态
        _uiState.value = UserUiState.Loading
    }
    .catch { exception ->
        // 捕获异常
        _uiState.value = UserUiState.Error(exception.message ?: "未知错误")
    }
    .collect { result ->
        // 收集结果
        result.fold(
            onSuccess = { users -> /* 处理成功 */ },
            onFailure = { exception -> /* 处理失败 */ }
        )
    }
```

### 6. Result 类型

**使用 Kotlin Result 类型：**

```kotlin
// Repository 返回 Result
suspend fun refreshUsers(): Result<List<User>> {
    return try {
        val users = fetchUsersFromNetwork()
        Result.success(users)
    } catch (e: Exception) {
        Result.failure(e)
    }
}

// ViewModel 处理 Result
result.fold(
    onSuccess = { users -> /* 成功处理 */ },
    onFailure = { exception -> /* 失败处理 */ }
)
```

## 架构对比

### 旧版本架构

```
View (Fragment)
    ↓ observe LiveData
ViewModel
    ↓ 直接创建
Repository (具体类)
    ↓
Model
```

### 新版本架构

```
View (Fragment) [@AndroidEntryPoint]
    ↓ collect StateFlow
ViewModel [@HiltViewModel]
    ↓ @Inject 注入接口
Repository (接口) ← Hilt 提供实现
    ↓
RepositoryImpl [@Singleton]
    ↓
Model
```

## 依赖配置

### build.gradle.kts (Project)

```kotlin
plugins {
    id("com.android.application") version "8.2.0" apply false
    id("org.jetbrains.kotlin.android") version "1.9.20" apply false
    id("com.google.dagger.hilt.android") version "2.50" apply false
}
```

### build.gradle.kts (App)

```kotlin
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    id("com.google.dagger.hilt.android")
    id("kotlin-kapt")
}

dependencies {
    // ViewModel
    implementation("androidx.lifecycle:lifecycle-viewmodel-ktx:2.7.0")
    // Lifecycle runtime
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.7.0")
    
    // Hilt
    implementation("com.google.dagger:hilt-android:2.50")
    kapt("com.google.dagger:hilt-android-compiler:2.50")
    
    // Coroutines
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3")
}
```

## 最佳实践总结

### 1. ViewModel 设计

```kotlin
@HiltViewModel
class UserViewModel @Inject constructor(
    private val repository: UserRepository
) : ViewModel() {
    
    // ✅ 使用私有 MutableStateFlow
    private val _uiState = MutableStateFlow<UserUiState>(UserUiState.Loading)
    val uiState: StateFlow<UserUiState> = _uiState.asStateFlow()
    
    // ✅ 使用 viewModelScope
    fun loadData() {
        viewModelScope.launch {
            // 异步操作
        }
    }
}
```

### 2. Repository 设计

```kotlin
interface UserRepository {
    fun getUsers(): Flow<Result<List<User>>>
}

@Singleton
class UserRepositoryImpl @Inject constructor(
    // 注入依赖
) : UserRepository {
    override fun getUsers(): Flow<Result<List<User>>> = flow {
        // 实现
    }
}
```

### 3. View 设计

```kotlin
@AndroidEntryPoint
class UserFragment : Fragment() {
    
    private val viewModel: UserViewModel by viewModels()
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        // ✅ 使用 repeatOnLifecycle
        viewLifecycleOwner.lifecycleScope.launch {
            viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.uiState.collect { state ->
                    handleUiState(state)
                }
            }
        }
    }
}
```

### 4. 依赖注入

```kotlin
// ✅ 使用接口
@HiltViewModel
class UserViewModel @Inject constructor(
    private val repository: UserRepository  // 接口
) : ViewModel()

// ✅ Module 绑定实现
@Module
@InstallIn(SingletonComponent::class)
abstract class AppModule {
    @Binds
    @Singleton
    abstract fun bindUserRepository(
        impl: UserRepositoryImpl
    ): UserRepository
}
```

## 测试优势

### ViewModel 单元测试

```kotlin
class UserViewModelTest {
    
    @Test
    fun `loadUsers should emit success state`() = runTest {
        // 创建 Mock Repository
        val mockRepository = mockk<UserRepository>()
        coEvery { mockRepository.getUsers() } returns flowOf(
            Result.success(listOf(User(1, "Test", "test@example.com")))
        )
        
        // 创建 ViewModel
        val viewModel = UserViewModel(mockRepository)
        
        // 验证状态
        val state = viewModel.uiState.value
        assertTrue(state is UserUiState.Success)
    }
}
```

## 迁移指南

如果你有旧的 LiveData 代码，可以按以下步骤迁移：

### 步骤 1: 添加依赖

在 `build.gradle.kts` 中添加 Hilt 和协程依赖。

### 步骤 2: 创建 Application 类

```kotlin
@HiltAndroidApp
class MvvmApplication : Application()
```

### 步骤 3: 转换 LiveData 为 StateFlow

```kotlin
// 旧代码
private val _data = MutableLiveData<String>()
val data: LiveData<String> = _data

// 新代码
private val _data = MutableStateFlow("")
val data: StateFlow<String> = _data.asStateFlow()
```

### 步骤 4: 更新观察方式

```kotlin
// 旧代码
viewModel.data.observe(viewLifecycleOwner) { value ->
    // 更新 UI
}

// 新代码
viewLifecycleOwner.lifecycleScope.launch {
    viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
        viewModel.data.collect { value ->
            // 更新 UI
        }
    }
}
```

### 步骤 5: 添加 Hilt 注解

在 Activity、Fragment、ViewModel 上添加相应的 Hilt 注解。

## 常见问题

### Q1: StateFlow 和 LiveData 的主要区别？

- StateFlow 需要初始值，LiveData 不需要
- StateFlow 是 Kotlin Flow 的一部分，支持更多操作符
- StateFlow 需要使用 `repeatOnLifecycle` 确保生命周期安全
- LiveData 自动处理生命周期，StateFlow 需要手动处理

### Q2: 什么时候使用 @Singleton？

当你希望整个应用只有一个实例时使用，通常用于 Repository。

### Q3: @Binds 和 @Provides 的区别？

- `@Binds`: 用于绑定接口和实现类（抽象方法）
- `@Provides`: 用于提供具体实例（普通方法）

### Q4: 为什么使用 repeatOnLifecycle？

确保 Fragment 不可见时停止收集 Flow，避免资源浪费和潜在的崩溃。

## 参考资源

- [Android 官方架构指南](https://developer.android.com/topic/architecture)
- [Hilt 官方文档](https://developer.android.com/training/dependency-injection/hilt-android)
- [StateFlow 和 SharedFlow](https://developer.android.com/kotlin/flow/stateflow-and-sharedflow)
- [Kotlin Flow 官方文档](https://kotlinlang.org/docs/flow.html)
